<?xml version="1.0" encoding="UTF-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
 <link href="http://arxiv.org/api/query?search_query%3Dall%3Amachine%26id_list%3D%26start%3D0%26max_results%3D10" rel="self" type="application/atom+xml"/>
 <title type="html">
  ArXiv Query: search_query=all:machine&amp;id_list=&amp;start=0&amp;max_results=10
 </title>
 <id>
  http://arxiv.org/api/VQq7Mwo79uDuW5vl7wMPUQmkqHo
 </id>
 <updated>
  2019-04-12T00:00:00-04:00
 </updated>
 <opensearch:totalresults xmlns:opensearch="http://a9.com/-/spec/opensearch/1.1/">
  54936
 </opensearch:totalresults>
 <opensearch:startindex xmlns:opensearch="http://a9.com/-/spec/opensearch/1.1/">
  0
 </opensearch:startindex>
 <opensearch:itemsperpage xmlns:opensearch="http://a9.com/-/spec/opensearch/1.1/">
  10
 </opensearch:itemsperpage>
 <entry>
  <id>
   http://arxiv.org/abs/1611.00467v1
  </id>
  <updated>
   2016-11-02T04:37:13Z
  </updated>
  <published>
   2016-11-02T04:37:13Z
  </published>
  <title>
   A Performance Survey on Stack-based and Register-based Virtual Machines
  </title>
  <summary>
   Virtual machines have been widely adapted for high-level programming language
implementations and for providing a degree of platform neutrality. As the
overall use and adaptation of virtual machines grow, the overall performance of
virtual machines has become a widely-discussed topic. In this paper, we present
a survey on the performance differences of the two most widely adapted types of
virtual machines - the stack-based virtual machine and the register-based
virtual machine - using various benchmark programs. Additionally, we adopted a
new approach of measuring performance by measuring the overall dispatch time,
amount of dispatches, fetch time, and execution time while running benchmarks
on custom-implemented, lightweight virtual machines. Finally, we present two
lightweight, custom-designed, Turing-equivalent virtual machines that are
specifically designed in benchmarking virtual machine performance - the
"Conceptum" stack-based virtual machine, and the "Inertia" register-based
virtual machine. Our result showed that while on average the register machine
spends 20.39% less time in executing benchmarks than the stack machine, the
stack-based virtual machine is still faster than the virtual machine regarding
the instruction fetch time.
  </summary>
  <author>
   <name>
    Ruijie Fang
   </name>
  </author>
  <author>
   <name>
    Siqi Liu
   </name>
  </author>
  <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">
   Short paper for evaluating performance differences between a
  stack-based and a register-based virtual machine
  </arxiv:comment>
  <link href="http://arxiv.org/abs/1611.00467v1" rel="alternate" type="text/html"/>
  <link href="http://arxiv.org/pdf/1611.00467v1" rel="related" title="pdf" type="application/pdf"/>
  <arxiv:primary_category scheme="http://arxiv.org/schemas/atom" term="cs.PL" xmlns:arxiv="http://arxiv.org/schemas/atom">
  </arxiv:primary_category>
  <category scheme="http://arxiv.org/schemas/atom" term="cs.PL">
  </category>
 </entry>
 <entry>
  <id>
   http://arxiv.org/abs/0910.1761v1
  </id>
  <updated>
   2009-10-09T14:37:04Z
  </updated>
  <published>
   2009-10-09T14:37:04Z
  </published>
  <title>
   Decomposition of forging dies for machining planning
  </title>
  <summary>
   This paper will provide a method to decompose forging dies for machining
planning in the case of high speed machining finishing operations. This method
lies on a machining feature approach model presented in the following paper.
The two main decomposition phases, called Basic Machining Features Extraction
and Process Planning Generation, are presented. These two decomposition phases
integrates machining resources models and expert machining knowledge to provide
an outstanding process planning.
  </summary>
  <author>
   <name>
    Laurent Tapie
   </name>
   <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">
    LURPA
   </arxiv:affiliation>
  </author>
  <author>
   <name>
    Kwamiwi Mawussi
   </name>
   <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">
    LURPA
   </arxiv:affiliation>
  </author>
  <author>
   <name>
    Bernard Anselmetti
   </name>
   <arxiv:affiliation xmlns:arxiv="http://arxiv.org/schemas/atom">
    LURPA
   </arxiv:affiliation>
  </author>
  <link href="http://arxiv.org/abs/0910.1761v1" rel="alternate" type="text/html"/>
  <link href="http://arxiv.org/pdf/0910.1761v1" rel="related" title="pdf" type="application/pdf"/>
  <arxiv:primary_category scheme="http://arxiv.org/schemas/atom" term="cs.RO" xmlns:arxiv="http://arxiv.org/schemas/atom">
  </arxiv:primary_category>
  <category scheme="http://arxiv.org/schemas/atom" term="cs.RO">
  </category>
 </entry>
 <entry>
  <id>
   http://arxiv.org/abs/1811.04422v1
  </id>
  <updated>
   2018-11-11T14:28:34Z
  </updated>
  <published>
   2018-11-11T14:28:34Z
  </published>
  <title>
   An Optimal Control View of Adversarial Machine Learning
  </title>
  <summary>
   I describe an optimal control view of adversarial machine learning, where the
dynamical system is the machine learner, the input are adversarial actions, and
the control costs are defined by the adversary's goals to do harm and be hard
to detect. This view encompasses many types of adversarial machine learning,
including test-item attacks, training-data poisoning, and adversarial reward
shaping. The view encourages adversarial machine learning researcher to utilize
advances in control theory and reinforcement learning.
  </summary>
  <author>
   <name>
    Xiaojin Zhu
   </name>
  </author>
  <link href="http://arxiv.org/abs/1811.04422v1" rel="alternate" type="text/html"/>
  <link href="http://arxiv.org/pdf/1811.04422v1" rel="related" title="pdf" type="application/pdf"/>
  <arxiv:primary_category scheme="http://arxiv.org/schemas/atom" term="cs.LG" xmlns:arxiv="http://arxiv.org/schemas/atom">
  </arxiv:primary_category>
  <category scheme="http://arxiv.org/schemas/atom" term="cs.LG">
  </category>
  <category scheme="http://arxiv.org/schemas/atom" term="stat.ML">
  </category>
 </entry>
 <entry>
  <id>
   http://arxiv.org/abs/quant-ph/0508083v1
  </id>
  <updated>
   2005-08-10T10:41:33Z
  </updated>
  <published>
   2005-08-10T10:41:33Z
  </published>
  <title>
   Deletion of imperfect cloned copies
  </title>
  <summary>
   In this work, we design a deleting machine and shown that for some given
condition on machine parameters, it gives slightly better result than P-B
deleting machine [5,6]. Also it is shown that for some particular values of the
machine parameters it acts like Pati-Braunstein deleting machine. We also study
the combined effect of cloning and deleting machine, where at first the cloning
is done by some standard cloning machines such as Wootters-Zurek [1] and
Buzek-Hillery [2] cloning machine and then the copy mode is deleted by
Pati-Braunstein deleting machine or our prescribed deleting machine. After that
we examine the distortion of the input state and the fidelity of deletion .
  </summary>
  <author>
   <name>
    Satyabrata Adhikari
   </name>
  </author>
  <author>
   <name>
    Binayak. S. Choudhury
   </name>
  </author>
  <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">
   10 Pages
  </arxiv:comment>
  <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">
   J. Phys. A 37 (2004) 1
  </arxiv:journal_ref>
  <link href="http://arxiv.org/abs/quant-ph/0508083v1" rel="alternate" type="text/html"/>
  <link href="http://arxiv.org/pdf/quant-ph/0508083v1" rel="related" title="pdf" type="application/pdf"/>
  <arxiv:primary_category scheme="http://arxiv.org/schemas/atom" term="quant-ph" xmlns:arxiv="http://arxiv.org/schemas/atom">
  </arxiv:primary_category>
  <category scheme="http://arxiv.org/schemas/atom" term="quant-ph">
  </category>
 </entry>
 <entry>
  <id>
   http://arxiv.org/abs/1007.3303v1
  </id>
  <updated>
   2010-07-19T22:53:06Z
  </updated>
  <published>
   2010-07-19T22:53:06Z
  </published>
  <title>
   A New Approach to Abstract Machines - Introduction to the Theory of
  Configuration Machines
  </title>
  <summary>
   An abstract machine is a theoretical model designed to perform a rigorous
study of computation. Such a model usually consists of configurations,
instructions, programs, inputs and outputs for the machine. In this paper we
formalize these notions as a very simple algebraic system, called a
configuration machine. If an abstract machine is defined as a configuration
machine consisting of primitive recursive functions then the functions computed
by the machine are always recursive. The theory of configuration machines
provides a useful tool to study universal machines.
  </summary>
  <author>
   <name>
    Zhaohua Luo
   </name>
  </author>
  <link href="http://arxiv.org/abs/1007.3303v1" rel="alternate" type="text/html"/>
  <link href="http://arxiv.org/pdf/1007.3303v1" rel="related" title="pdf" type="application/pdf"/>
  <arxiv:primary_category scheme="http://arxiv.org/schemas/atom" term="cs.LO" xmlns:arxiv="http://arxiv.org/schemas/atom">
  </arxiv:primary_category>
  <category scheme="http://arxiv.org/schemas/atom" term="cs.LO">
  </category>
  <category scheme="http://arxiv.org/schemas/atom" term="cs.FL">
  </category>
  <category scheme="http://arxiv.org/schemas/atom" term="math.LO">
  </category>
 </entry>
 <entry>
  <id>
   http://arxiv.org/abs/1212.2686v1
  </id>
  <updated>
   2012-12-12T01:59:27Z
  </updated>
  <published>
   2012-12-12T01:59:27Z
  </published>
  <title>
   Joint Training of Deep Boltzmann Machines
  </title>
  <summary>
   We introduce a new method for training deep Boltzmann machines jointly. Prior
methods require an initial learning pass that trains the deep Boltzmann machine
greedily, one layer at a time, or do not perform well on classifi- cation
tasks.
  </summary>
  <author>
   <name>
    Ian Goodfellow
   </name>
  </author>
  <author>
   <name>
    Aaron Courville
   </name>
  </author>
  <author>
   <name>
    Yoshua Bengio
   </name>
  </author>
  <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">
   4 pages
  </arxiv:comment>
  <link href="http://arxiv.org/abs/1212.2686v1" rel="alternate" type="text/html"/>
  <link href="http://arxiv.org/pdf/1212.2686v1" rel="related" title="pdf" type="application/pdf"/>
  <arxiv:primary_category scheme="http://arxiv.org/schemas/atom" term="stat.ML" xmlns:arxiv="http://arxiv.org/schemas/atom">
  </arxiv:primary_category>
  <category scheme="http://arxiv.org/schemas/atom" term="stat.ML">
  </category>
  <category scheme="http://arxiv.org/schemas/atom" term="cs.LG">
  </category>
 </entry>
 <entry>
  <id>
   http://arxiv.org/abs/1804.06022v1
  </id>
  <updated>
   2018-04-17T03:03:06Z
  </updated>
  <published>
   2018-04-17T03:03:06Z
  </published>
  <title>
   Predicting Future Machine Failure from Machine State Using Logistic
  Regression
  </title>
  <summary>
   Accurately predicting machine failures in advance can decrease maintenance
cost and help allocate maintenance resources more efficiently. Logistic
regression was applied to predict machine state 24 hours in the future given
the current machine state.
  </summary>
  <author>
   <name>
    Matthew Battifarano
   </name>
  </author>
  <author>
   <name>
    David DeSmet
   </name>
  </author>
  <author>
   <name>
    Achyuth Madabhushi
   </name>
  </author>
  <author>
   <name>
    Parth Nabar
   </name>
  </author>
  <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">
   5 pages, 3 figures
  </arxiv:comment>
  <link href="http://arxiv.org/abs/1804.06022v1" rel="alternate" type="text/html"/>
  <link href="http://arxiv.org/pdf/1804.06022v1" rel="related" title="pdf" type="application/pdf"/>
  <arxiv:primary_category scheme="http://arxiv.org/schemas/atom" term="stat.AP" xmlns:arxiv="http://arxiv.org/schemas/atom">
  </arxiv:primary_category>
  <category scheme="http://arxiv.org/schemas/atom" term="stat.AP">
  </category>
 </entry>
 <entry>
  <id>
   http://arxiv.org/abs/quant-ph/0501176v2
  </id>
  <updated>
   2005-06-06T17:29:54Z
  </updated>
  <published>
   2005-01-30T04:42:12Z
  </published>
  <title>
   Simulations of Quantum Turing Machines by Quantum Multi-Stack Machines
  </title>
  <summary>
   As was well known, in classical computation, Turing machines, circuits,
multi-stack machines, and multi-counter machines are equivalent, that is, they
can simulate each other in polynomial time. In quantum computation, Yao [11]
first proved that for any quantum Turing machines $M$, there exists quantum
Boolean circuit $(n,t)$-simulating $M$, where $n$ denotes the length of input
strings, and $t$ is the number of move steps before machine stopping. However,
the simulations of quantum Turing machines by quantum multi-stack machines and
quantum multi-counter machines have not been considered, and quantum
multi-stack machines have not been established, either. Though quantum counter
machines were dealt with by Kravtsev [6] and Yamasaki {\it et al.} [10], in
which the machines count with $0,\pm 1$ only, we sense that it is difficult to
simulate quantum Turing machines in terms of this fashion of quantum computing
devices, and we therefore prove that the quantum multi-counter machines allowed
to count with $0,\pm 1,\pm 2,...,\pm n$ for some $n&gt;1$ can efficiently simulate
quantum Turing machines.
  Therefore, our mail goals are to establish quantum multi-stack machines and
quantum multi-counter machines with counts $0,\pm 1,\pm 2,...,\pm n$ and $n&gt;1$,
and particularly to simulate quantum Turing machines by these quantum computing
devices.
  </summary>
  <author>
   <name>
    Daowen Qiu
   </name>
  </author>
  <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">
   25 pages
  </arxiv:comment>
  <link href="http://arxiv.org/abs/quant-ph/0501176v2" rel="alternate" type="text/html"/>
  <link href="http://arxiv.org/pdf/quant-ph/0501176v2" rel="related" title="pdf" type="application/pdf"/>
  <arxiv:primary_category scheme="http://arxiv.org/schemas/atom" term="quant-ph" xmlns:arxiv="http://arxiv.org/schemas/atom">
  </arxiv:primary_category>
  <category scheme="http://arxiv.org/schemas/atom" term="quant-ph">
  </category>
 </entry>
 <entry>
  <id>
   http://arxiv.org/abs/1304.0053v2
  </id>
  <updated>
   2014-08-05T18:34:14Z
  </updated>
  <published>
   2013-03-30T00:34:31Z
  </published>
  <title>
   Wang's B machines are efficiently universal, as is Hasenjaeger's small
  universal electromechanical toy
  </title>
  <summary>
   In the 1960's Gisbert Hasenjaeger built Turing Machines from
electromechanical relays and uniselectors. Recently, Glaschick reverse
engineered the program of one of these machines and found that it is a
universal Turing machine. In fact, its program uses only four states and two
symbols, making it a very small universal Turing machine. (The machine has
three tapes and a number of other features that are important to keep in mind
when comparing it to other small universal machines.) Hasenjaeger's machine
simulates Hao Wang's B machines, which were proved universal by Wang.
Unfortunately, Wang's original simulation algorithm suffers from an exponential
slowdown when simulating Turing machines. Hence, via this simulation,
Hasenjaeger's machine also has an exponential slowdown when simulating Turing
machines. In this work, we give a new efficient simulation algorithm for Wang's
B machines by showing that they simulate Turing machines with only a polynomial
slowdown. As a second result, we find that Hasenjaeger's machine also
efficiently simulates Turing machines in polynomial time. Thus, Hasenjaeger's
machine is both small and fast. In another application of our result, we show
that Hooper's small universal Turing machine simulates Turing machines in
polynomial time, an exponential improvement.
  </summary>
  <author>
   <name>
    Turlough Neary
   </name>
  </author>
  <author>
   <name>
    Damien Woods
   </name>
  </author>
  <author>
   <name>
    Niall Murphy
   </name>
  </author>
  <author>
   <name>
    Rainer Glaschick
   </name>
  </author>
  <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">
   18 pages, 1 figure, 1 table, Conference: Turing in context II -
  History and Philosophy of Computing, 2012
  </arxiv:comment>
  <arxiv:journal_ref xmlns:arxiv="http://arxiv.org/schemas/atom">
   Journal of Complexity, Volume 30, Issue 5, October 2014, pages
  634-646
  </arxiv:journal_ref>
  <link href="http://arxiv.org/abs/1304.0053v2" rel="alternate" type="text/html"/>
  <link href="http://arxiv.org/pdf/1304.0053v2" rel="related" title="pdf" type="application/pdf"/>
  <arxiv:primary_category scheme="http://arxiv.org/schemas/atom" term="cs.CC" xmlns:arxiv="http://arxiv.org/schemas/atom">
  </arxiv:primary_category>
  <category scheme="http://arxiv.org/schemas/atom" term="cs.CC">
  </category>
  <category scheme="http://arxiv.org/schemas/atom" term="cs.DS">
  </category>
  <category scheme="http://arxiv.org/schemas/atom" term="68Q05,">
  </category>
  <category scheme="http://arxiv.org/schemas/atom" term="F.1.1">
  </category>
 </entry>
 <entry>
  <id>
   http://arxiv.org/abs/quant-ph/0511211v1
  </id>
  <updated>
   2005-11-22T09:01:33Z
  </updated>
  <published>
   2005-11-22T09:01:33Z
  </published>
  <title>
   A Generalized Deletion Machine
  </title>
  <summary>
   In this work we prescribe a more generalized quantum-deleting machine (input
state dependent). The fidelity of deletion is dependent on some machine
parameters such that on alteration of machine parameters we get back to
standard deleting machines. We also carried out a various comparative study of
various kinds of quantum deleting machines. We also plotted graphs, making a
comparative study of fidelity of deletion of the deletion machines, obtained as
particular cases on changing the machine parameters of our machine.
  </summary>
  <author>
   <name>
    Indranil Chakrabarty
   </name>
  </author>
  <author>
   <name>
    Satyabrata Adhikari
   </name>
  </author>
  <arxiv:comment xmlns:arxiv="http://arxiv.org/schemas/atom">
   5 pages,To appear in Erato Conference Proceedings
  </arxiv:comment>
  <link href="http://arxiv.org/abs/quant-ph/0511211v1" rel="alternate" type="text/html"/>
  <link href="http://arxiv.org/pdf/quant-ph/0511211v1" rel="related" title="pdf" type="application/pdf"/>
  <arxiv:primary_category scheme="http://arxiv.org/schemas/atom" term="quant-ph" xmlns:arxiv="http://arxiv.org/schemas/atom">
  </arxiv:primary_category>
  <category scheme="http://arxiv.org/schemas/atom" term="quant-ph">
  </category>
 </entry>
</feed>
